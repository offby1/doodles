-*-text-*-

* Vector-trie

  We need to keep track of which sentences we've already seen, yes?
  So try this: reduce a template like

  ( "foo" (#\a . 0) "bar" (#\q . 3) "zap" (#\z . 9))

  to a list like (0 3 9) -- then note that list by using a sort of
  vector-trie -- one vector that represents the counts for the first
  letter, whose 0th element we'll set to a vector that represents the
  counts for the second letter, whose 3rd element gets set to a vector
  that represents the third letter, whose 9th element we'll set to #t.

  The amount of storage used per try will be one vector per cons in
  the template -- in our example above, there are three conses, so
  we'd need three vectors per try.  And each vector's length will be
  determined by the maximum count we're willing to store.  Say that's
  30; so our example above will use 3 vectors of length 30.  We'd like
  to be able to store a million tries easily, which would be 90
  million slots, each of which is presumably a 4-byte word.  That's a
  lot of memory, but perhaps it's doable.

* set the monitor's "sleep" delay on the command line

* Show estimated time of completion.

* ambitious: GUI it

  It'd be fun to watch the progress graphically.  Imagine that the
  conses in the template are represented by what looks like an
  odometer -- little wheels.  Each would have a label under it to tell
  what letter it corresponds with.  So if the template were currently

        ("Yo: " (#\a . 10) ", " (#\s . 4) " and " (#\t . 8) ".")

  the thing would look like

                ____  ____  ____
                |10|  | 4|  | 8|
                ----  ----  ----
                  a     s     t

  and they'd whirl by.

* Count backwards

  Let's say I've set *min* to 1 and *max* to 14.  Since finished
  sentences might well have closer to 14 of a particular letter than
  1, we'd find the truth faster by counting backwards.

* Give each letter its own min and max

  ... instead of having them be global.  Thus e's max might be 20
  whereas q's would be 1.

* For the case when we're following loops through the multidimensional
  space, arrange a break handler so that when I hit Control-C, before
  quitting, it gives me statistics about how full the count->boolean
  map is.

* Trap the runtime error ``vector-ref: index blah out of range'', and
  automatically bump *max* and restart.

* limit the memory the process can use, to prevent it from bringing
  the computer to its knees.  (ulimit -d 100000; mzscheme -qu
  ./autogram.ss) is a crude way to do it.

* Find a way to tell the monitor thread to wake up and do its thing
  _now_.  That way when we're shutting down we can get one last report
  out of it.
