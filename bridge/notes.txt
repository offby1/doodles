-*-outline-*-
Thoughts about a bridge program based on a "double-dummy solver".

Inspired by http://www.gibware.com/reviews/bw.html, or something like
it.

* What is it?

A double-dummy solver is a function that, given

- north's holding
- east's holding
- south's holding
- west's holding
- which of the four hands makes the opening lead
- the trump suit

figures out the number of tricks that the declarer will take.  It
assumes that all four players play as well as possible.  I'm not
entirely sure what that means, but each player can see each other's
cards (that's why it's called "double-dummy"), so there shouldn't be
too much ambiguity.

** open questions

However, here are some things that are nevertheless uncertain:

*** Which card to play

When faced with a choice of two cards to play, both of which will
clearly win, which should it choose?  

    Perhaps it should, say, always play the higher, on the assumption
    that that will communicate something useful to partner.  On second
    thought, though, that's silly; there's nothing to communicate,
    since each player can see everything.

Similarly, when faced with a choice of two cards to play, both of
which will clearly _lose_, which should it choose?

Related to the first question: when the two cards will both clearly
win, but one of them will cause the trick to be won by me, and the
other by my partner, which should it choose?

    I suspect that the idea of unblocking a suit (i.e., playing the
    high card from the short suit first, as they taught us in beginner
    class) is relevant here.

Is there ever a case when it should play a losing card, despite
holding a winning card?  (This is called "ducking":
http://en.wikipedia.org/wiki/Duck_%28bridge%29)

    Yes: that's why defenders "hold up" at notrump.
    http://en.wikipedia.org/wiki/Holdup_%28bridge%29 Obviously, losing
    that trick now only makes sense if the tactic gains me _two_ or
    more otherwise unavailable tricks.

Is there ever a case where it's not clear whether a particular card
would win?

      Presumably, yes: when the opponents might duck.

* How would you use it?

** Bidding

For each possible call that is legal for me, predict the score that
will result if I make it, and then pick the call that yields the
biggest score.

Brute force indeed!

Now, how does one predict the score of a bid?  Well, there's one case
that's really easy: when it's the third pass, and we thus are certain
who the declarer will be, and what the contract will be.  In that
case, we simply run our double-dummy solver a bunch of times, and pick
the most likely result, and score that.

In the other cases, we'd call ourselves recursively, after positing
some call.  See the pseudo-code.



(define (make-call auction-so-far)
  (let ((best-hypothetical-auction (car (sort (predict-scores auction-so-far)
                                 (lambda (s1 s2)
                                   (< (car s1)
                                      (car s2)))))))

    ;; This simply counts the number of calls in auction-so-far, and
    ;; then skips that many in best-hypothetical-auction.
    (my-next-call best-hypothetical-auction)))


;; Given a possibly-incomplete auction, figure out every possible
;; auction that could follow from it, and the score each would yield.
;; Boy, I bet there are a lot of them :-(

;; the recursive calls are guaranteed to terminate eventually, because
;; extending an auction brings it "closer" to completion.

;; an obvious postcondition: auction-so-far must be a prefix of each
;; returned auction.
(define (predict-scores auction-so-far)
  (if (auction-is-completed)
      (cons

       ;; perhaps, rather than finding the most likely score, I should
       ;; find the _average_ score.

       (most-likely-score (extract-incomplete-knowledge auction-so-far)
                          auction-so-far)
       auction-so-far)

    (map (lambda (one-possible-call)
           (let ((extended (extend-auction auction-so-far one-possible-call)))
             (cons (predict-scores extended) extended)))

         ;; possible optimization: rather than considering _every_
         ;; legal call I could make, consider only the "first" few,
         ;; where "first" means "lowest level".

         (all-legal-calls-I-could-make-now auction-so-far)
         )))


;; (most-frequently-occurring (list 1 2 3 3 4 5 6 2 2 2)) => 2

(define (most-likely-score incomplete-hand-knowledge auction)
  (score-from-result
   (reduce
    most-frequently-occurring
    (map (lambda (one-possible-hand))
         (dds:number-of-declarer-tricks one-possible-hand))
    (generate-lotsa-plausible-hands incomplete-hand-knowledge ))
   auction)
  )

;; (score-from-result 3 '(two notrump east not-doubled vulnerable)) => 150



** Playing

Probably similar to bidding: for each card that it's legal for me to
play, see what the score would be if I _did_ play it, and choose the
card with the highest score.

How does one predict the score, given a card and a game-so-far?

The easy case: this is the last card of the hand.  In that case, we
know the actual number of tricks taken by the declarer, so we can just
figure out the score.

The recursive case: "posit" this card, and call ourselves recursively.

;; Note the similarity between this and the auction stuff above.
;; Refactoring clearly needed.

(define (choose-card completed-auction play-so-far)
  (let ((best-hypothetical-course-of-play 
         (car (sort (predict-scores completed-auction play-so-far)
                    (lambda (s1 s2)
                      (< (car s1)
                         (car s2)))))))

    ;; This simply counts the number of tricks in play-so-far, and
    ;; then skips that many in best-hypothetical-course-of-play.
    (my-next-play best-hypothetical-course-of-play)))


;; given a completed auction, and zero or more records of who played
;; which card, predict all the possible future games, and their
;; scores, and return them all.
(define (predict-scores completed-auction play-so-far)
  (if (this-is-the-fifty-second-card)
      (cons

       (most-likely-score (extract-incomplete-knowledge completed-auction play-so-far)
                          completed-auction play-so-far)
       play-so-far)

    (map (lambda (one-possible-card)
           (let ((extended (extend-play-history completed-auction play-so-far one-possible-card)))
             (cons (predict-scores completed-auction extended) extended)))

         (all-legal-cards-I-could-now-play completed-auction play-so-far)
         )))

(define (most-likely-score incomplete-hand-knowledge auction play-so-far)
  (score-from-result
   (reduce
    most-frequently-occurring
    (map (lambda (one-possible-hand))
         (dds:number-of-declarer-tricks one-possible-hand))
    (generate-lotsa-plausible-hands incomplete-hand-knowledge ))
   auction)
  )
 
** How do I represent incomplete knowledge of a hand?

The only thing I've thought of so far is a list of predicates: for
example, if all I know is that the hand has either five or six spades,
I'd construct a function like

    (lambda (hand) (< 4 (count-spades hand) 7))

and add it to a list of such functions.  That list would constitute my
knowledge of the hand.

Such a list might work, but seems crude.  For example, if a list had
the above entry, along with the similar entry

    (lambda (hand) (< 4 (count-spades hand) 8))

it'd sure be nice to be able to recognize that the first is redundant,
but given that the only thing one can do with a function is call it,
this seems difficult.

The right solution is probably a language to describe partial
knowledge of bridge hands ... but that sounds mighty daunting.

* Implementation thoughts

If I really do the brute-force approach outlined above, then it'll be
crucial that I be able to profile the code, since it's likely to do
_lots_ of computation.  Unfortunately Guile as of version 1.7.2 (which
is a prerelease) doesn't seem to have any profiling support whatever.
mzscheme does, and Common Lisp does.  I tend towards Scheme since I
spend less time looking stuff up in the reference.

* Testing

Lots of records of real hands are at
http://www.sarantakos.com/bridge/vugraph.html; if I ever write
something that claims to work, I could compare its results to those.
