-*-outline-*-
Thoughts about a bridge program based on a "double-dummy solver".

Inspired by http://www.gibware.com/reviews/bw.html, or something like
it.

* What is it?

A double-dummy solver is a function that, given

- north's holding
- east's holding
- south's holding
- west's holding
- which of the four hands makes the opening lead
- the trump suit

figures out the number of tricks that the declarer will take.  It
assumes that all four players play as well as possible.  I'm not
entirely sure what that means, but each player can see each other's
cards (that's why it's called "double-dummy"), so there shouldn't be
too much ambiguity.

** open questions

However, here are some things that are nevertheless uncertain:

*** Which card to play

When faced with a choice of two cards to play, both of which will
clearly win, which should it choose?  

    Perhaps it should, say, always play the higher, on the assumption
    that that will communicate something useful to partner.  On second
    thought, though, that's silly; there's nothing to communicate,
    since each player can see everything.

Similarly, when faced with a choice of two cards to play, both of
which will clearly _lose_, which should it choose?

Related to the first question: when the two cards will both clearly
win, but one of them will cause the trick to be won by me, and the
other by my partner, which should it choose?

    I suspect that the idea of unblocking a suit (i.e., playing the
    high card from the short suit first, as they taught us in beginner
    class) is relevant here.

Is there ever a case when it should play a losing card, despite
holding a winning card?  (This is called "ducking":
http://en.wikipedia.org/wiki/Duck_%28bridge%29)

    Yes: that's why defenders "hold up" at notrump.
    http://en.wikipedia.org/wiki/Holdup_%28bridge%29 Obviously, losing
    that trick now only makes sense if the tactic gains me _two_ or
    more otherwise unavailable tricks.

* How would you use it?

** First idea

Here's how one might base a complete game around this solver:

Bidding: every time I hear another player make a call, I figure out
what that call "means" (e.g., in Standard American, opening one spade
"means" the opener has at least 12 high card points, at least five
spades, more spades than hearts), create a little function that
returns true for all such hands and false for all others, and add that
function to a list of such functions for that hand.  That list of
functions represents my (incomplete) picture of the hand.  Presumably
as the auction continues, I'll add more and more descriptive functions
to the list.

[This sounds very tedious; I'd have to have a big database showing
what each call means in certain contexts]

Now when it's my turn to make a call (and this probably applies to
playing a card, too), I enumerate all the legal possibilities.  (If
the auction has just started, for example, there are seven levels
times five denominations = 35 bids, plus "pass", available to me; if
an opponent has made the last bid, then "double" might be available,
etc).  Each possibility determines a trump suit, and we'll assume I'll
be the declarer; that determines who'd make the opening lead (namely
my left-hand opponent).  Now I deal out a bunch of random hands that
conform to what I know -- that is, each hand passes all the predicates
that I've saved up in my list.  So now I've got, let's say, 100 deals,
each of which is plausible given what I know of the auction (and
perhaps the play).

For each such deal, I now have the four holdings, the opening leader,
and the trump suit; I now run the double-dummy solver to see how many
tricks I'd take.  I figure out the resulting score, based on the
contract (I'm not sure how I figure the precise contract -- should I
assume the opponents double, or not? {Since each player always makes
the best possible call, I should probably assume that it will be
doubled if and only if it's a sacrifice bid -- i.e., one which I don't
expect to make.})

So now I have a bunch of possible contracts, and a score for each.  I
pick the one whose score is best for me _and_ for which I'm the
declarer.  That's my bid.

    This strategy means that every bid I make is natural.  This is
    probably silly, but hey, it's all preliminary.

(I assume that regardless of holding, the best contract for me is
always going to be the opponents playing seven notrump redoubled, but
I cannot force them to get to that contract; I can only control the
calls that _I_ make.  {In Version 2, I'll be able to 'control' the
calls that my _partner_ makes by using a bidding system :-}.  That's
why I choose the highest-scoring contract for which I'm the declarer.)

** Second idea

(Actually, this is the same as the first idea above, just {perhaps}
better explained.)

For each possible call that is legal for me, predict the score that
will result if I make it, and then pick the call that yields the
biggest score.

Brute force indeed!

Now, how does one predict the score of a bid?  Well, there's one case
that's really easy: when it's the third pass, and we thus are certain
who the declarer will be, and what the contract will be.  In that
case, we simply run our double-dummy solver a bunch of times, and pick
the most likely result, and score that.

In the other cases, we'd call ourselves recursively, after positing
some call.  See the pseudo-code.



(define (make-call auction-so-far)
  (let ((best-hypothetical-auction (car (sort (predict-scores auction-so-far)
                                 (lambda (s1 s2)
                                   (< (car s1)
                                      (car s2)))))))

    ;; This simply counts the number of calls in auction-so-far, and
    ;; then skips that many in best-hypothetical-auction.
    (my-next-call best-hypothetical-auction)))


;; Given a possibly-incomplete auction, figure out every possible
;; auction that could follow from it, and the score each would yield.
;; Boy, I bet there are a lot of them :-(

;; the recursive calls are guaranteed to terminate eventually, because
;; extending an auction brings it "closer" to completion.

;; an obvious postcondition: auction-so-far must be a prefix of each
;; returned auction.
(define (predict-scores auction-so-far)
  (if (auction-is-completed)
      (cons

       ;; perhaps, rather than finding the most likely score, I should
       ;; find the _average_ score.

       (most-likely-score (extract-incomplete-knowledge auction-so-far)
                          auction-so-far)
       auction-so-far)

    (map (lambda (one-possible-call)
           (let ((extended (extend-auction auction-so-far one-possible-call)))
             (cons (predict-scores extended) extended)))

         ;; possible optimization: rather than considering _every_
         ;; legal call I could make, consider only the "first" few,
         ;; where "first" means "lowest level".

         (all-legal-calls-I-could-make-now auction-so-far)
         )))


;; (most-frequently-occurring (list 1 2 3 3 4 5 6 2 2 2)) => 2

(define (most-likely-score incomplete-hand-knowledge auction)
  (score-from-result
   (reduce
    most-frequently-occurring
    (map (lambda (one-possible-hand))
         (dds:number-of-declarer-tricks one-possible-hand))
    (generate-lotsa-plausible-hands incomplete-hand-knowledge ))
   auction)
  )

;; (score-from-result 3 '(two notrump east not-doubled vulnerable)) => 150



** How do I represent incomplete knowledge of a hand?

The only thing I've thought of so far is a list of predicates: for
example, if all I know is that the hand has either five or six spades,
I'd construct a function like

    (lambda (hand) (< 4 (count-spades hand) 7))

and add it to a list of such functions.  That list would constitute my
knowledge of the hand.

Such a list might work, but seems crude.  For example, if a list had
the above entry, along with the similar entry

    (lambda (hand) (< 4 (count-spades hand) 8))

it'd sure be nice to be able to recognize that the first is redundant,
but given that the only thing one can do with a function is call it,
this seems difficult.


* Implementation thoughts

If I really do the brute-force approach outlined above, then it'll be
crucial that I be able to profile the code, since it's likely to do
_lots_ of computation.  Unfortunately Guile as of version 1.7.2 (which
is a prerelease) doesn't seem to have any profiling support whatever.
mzscheme does, and Common Lisp does.  I tend towards Scheme since I
spend less time looking stuff up in the reference.

* Testing

Lots of records of real hands are at
http://www.sarantakos.com/bridge/vugraph.html; if I ever write
something that claims to work, I could compare its results to those.
