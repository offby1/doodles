-*- outline -*-

A grab bag of ideas that are applicable to all the implementations,
but probably appear only in some.

* Store the dictionary as a list, not a hash.

There's no need for it to be a hash, since the anagram algorithm
doesn't need to do any lookups; it merely needs to traverse.  Using a
list lets us sort the entries in interesting ways (such as: biggest
words first).

* Use a simple string of sorted letters as the bag.

This isn't necessarily better than any other method for all
implementations, but it seems the best for Perl, since it can be used
as a hash key (convenient when reading the dictionary).  And anyway,
subtracting two such things ought to be fast, assuming that substr is
fast.

And yet I tried this first when writing the C++ version.  It worked
OK, but I then tried using bignums ... and they were twice as fast.
Hmm.

* Use a simple list of bags as the exclusions.

For all I know, I'm already doing this in all implementations.
Anyway, I've never seen any speed improvement with a more complex idea
(such as a list of hash tables).

Although a simple hash table, which we deep-copy upon entry to the
function, probably would work too.

* Emit top-level anagrams as they're found.

To alleviate boredom.  This requires sorting the dictionary by biggest
words first, as described above.  Well, OK, it doesn't _require_ it, but
it's much nicer that way.

* Sort anagrams in the dictionary.

The dictionary maps each "bag" to a list of words that can be made
from that bag.  Make sure that list is in alphabetical order, so that
the returned list of anagrams is sorted too.

* Use `configure' to figure out where the dictionary lives.

I've only tried the programs on a few computers, and yet each has the
dictionary in a different place.  Windows is of course particularly
bad.  If using `configure' is too complicated, perhaps just an
environment variable.
