<j85wilson> so basically, you are trying to multiplex a port?                              [08:55]
<zbigniew> offby1: so, what are you using this for?                                        [08:57]
<offby1> I'm not using it yet but I'm thinking of making my IRC bot (rudybot) use it ...
<offby1> ... as a way of keeping separate threads really separate
<offby1> each gets a copy of the input stream                                              [09:00]
<offby1> without disturbing the others
<offby1> might be a very dumb idea
<offby1> might be brilliant
<offby1> dunno yet
<j85wilson> I think I want to build a steam powered car.  That'd be fun
<zbigniew> 1 thread/channel?
<offby1> zbigniew: possibly more than 1 thread per channel
<j85wilson> offby1: I think it sounds like a neat idea
<j85wilson> big.
<offby1> zbigniew: one thread would emit clever quotes; one would spew the occasional news
<j85wilson> rudebot: quote                                                                 [09:01]
<offby1> rudybot: quote
<j85wilson> you keep changing the name
<offby1> I do
<offby1> I've registered both rudybot and rudebot so it's unlikely I'll need to change much more
<zbigniew> offby1: i see two issues (assuming i understand the code)
<offby1> he doesn't do it here, but in #emacs he (in theory) spews quotes every 20 minutes if the
<offby1> zbigniew: do tell
<zbigniew> 1) input copied for each thread
<offby1> zbigniew: sure
<j85wilson> jcowan, either carry a lot of water, or only drive in the rain.
<offby1> jcowan: I originally named it "fartbot" because of my condition when I first started
<zbigniew> 2) at the moment you can only do a two-way split, so to multiplex you will have copies
<offby1> zbigniew: 2) is clear to me
<offby1> zbigniew: there's nothing hard about passing in a number and making that many, instead
<offby1> zbigniew: but it's not obvious that copies of copies of copies would be that bad.
<offby1> note that mzscheme lets me limit a pipe's capacity                                [09:04]
<zbigniew> 2) is bad in my opinion simply due to the high overhead                         [09:05]
<j85wilson> and at any time, if all the pointers have gone past some item, you can gc that item.
<j85wilson> (port->stream ...)                                                             [09:07]
<j85wilson> then each thread can cdr down the stream as it likes
<zbigniew> is it august 5th already?  crap.                                                [09:08]
<j85wilson> call/cc
<zbigniew> not unless you use call/cc.  which you don't want to
<zbigniew> trust me
<j85wilson> expound, zbigniew, expound.
<zbigniew> defcons: explain why you're trying to break out of a let*
<defcons> zbigniew, if something early on in the definitions is false, I don't want other
<zbigniew> defcons: use AND-LET* (srfi-2)
<j85wilson> curse you, zbigniew, and your quicker fingers than mine!
<zbigniew> good luck getting anything accomplished without srfis :)
<j85wilson> why don't you like srfis?
<zbigniew> you could write them yourself, but why?                                         [09:14]
<zbigniew> ... and?
<j85wilson> but... most of them are in more implementations than any implementation specific
<j85wilson> MzScheme is PLT.
<j85wilson> try (require-extension (srfi 2))
<j85wilson> (that syntax is itself a srfi...
<zbigniew> defcons: like duncam said, all you have to do is use a combination of AND and LET to
<zbigniew> no need to use call/cc to alter the flow of control.                            [09:16]
<zbigniew> Yes.
<zbigniew> (let ((b ...)) (and b (let ((c ...)) (and c ...) ...)                           [09:18]
<j85wilson> zbigniew, that is uglifericious!
<zbigniew> No, it's not.
<j85wilson> yes it is.
<zbigniew> It's not any uglier than replacing the AND with IF ...                          [09:19]
<zbigniew> Yes, but that's how you do it completely within r5rs
<j85wilson> true
<j85wilson> that doesn't make it pretty.
<zbigniew> Cin: implement that without using multiple lets or call/cc                      [09:20]
<Cin> zbigniew: lol let* and if suffice
<j85wilson> I'd rather use call/cc.
<j85wilson> parenscript?
<zbigniew> Cin: certainly not.
<j85wilson> http://common-lisp.net/project/parenscript/                                    [09:21]
<j85wilson> nope
<j85wilson> I understand that it is really just javascript with lisp syntax, but never having
<Cin> zbigniew: http://paste.lisp.org/display/45523                                        [09:22]
<j85wilson> pshaw, what they don't know won't hurt them.
<j85wilson> goo, I said pshaw twice in two days.  now I feel geezerly.
<Cin> zbigniew: doesn't that cover this problem?
<zbigniew> Cin: okay ... so you implemented it with multiple LAMBDAs and IFs...
<j85wilson> zbigniew: to do it completely within r5rs, use syntax-rules to write and-let*.
<zbigniew> LET is LAMBDA
<zbigniew> oh sorry, i didn't see there was an annotation ... hold on                      [09:24]
<zbigniew> right.  it doesn't short-circuit.
<zbigniew> j85wilson: I'm a fan of and-let* when appropriate, so you don't have to convince me
<j85wilson> I'm just sayin', and-let* can be done in pure r5rs without resorting to horribly
* zbigniew notices nerdcore has hit the MSM, scant weeks after cat macros
<zbigniew> it is the end times
<j85wilson> ahh nerdcore                                                                   [09:28]
<j85wilson> agree.                                                                         [09:30]
<zbigniew> use foof's fmt combinator?
<zbigniew> i know, i know, it's not in r5rs.
<zbigniew> then again, neither is printf!                                                  [09:32]
<j85wilson> it is not a problem that I have solved.
<zbigniew> defcons: http://synthcode.com/scheme/fmt/                                       [09:34]
<zbigniew> foof: this is the first time I actually looked at fmt-c and I must say it looks grand
<zbigniew> the dungeon collapses!!                                                         [10:04]
<zbigniew> If it's a list of lists, just use write.                                        [10:11]
<zbigniew> According to that page, structures are printed in vector form by default (unless they
<zbigniew> type (print-struct)
<zbigniew> i mean what was the return value
<zbigniew> hmm, then I don't know why it's not expanded by default                         [10:21]
<zbigniew> if your lists only contain structures, then just do (write (map struct->vector L))
<zbigniew> otherwise I apologize because I don't know PLT                                  [10:23]
<zbigniew> e.g. (map vector->struct (read))
<zbigniew> the straightforward way to do this is to convert the structures to lists (tagged by
<zbigniew> basically like Cin said ... though Cin, won't that vector contain a tag as its first
<zbigniew> i bet mzscheme can read and write structure data natively; we just can't figure it out
<offby1> <zbigniew> 2) (to multiplex you will have copies of copies) is bad in my opinion simply
<offby1> hmm
<zbigniew> is that not true?
<offby1> that's one of those things that sounds plausible, but I won't worry about it until it
<offby1> overhead of what, precisely?
<zbigniew> if you implement your idea of splitting the same stream into more than 2 copies, it
<offby1> how much better, and why?                                                         [10:42]
<zbigniew> but as far as I can see, if you split from an existing split you'll have
<offby1> oh, that's true                                                                   [10:43]
<offby1> gotcha
<j85wilson> I'd still recommend using streams instead of ports
<offby1> no idea what the real cost of that is, though
<j85wilson> each thread can cdr down the stream without disturbing the others
<offby1> j85wilson: well ... I want to pass these ports to procedures that _take_ ports
<zbigniew> offby1: honestly, i would just write a reasonable api and implement it however, and
<offby1> I don't want to have to teach those procedures to deal with streams
<j85wilson> so convert them to ports to pass them.
<offby1> zbigniew: indeed!
<zbigniew> "time and space can be a bitch"
<offby1> j85wilson: hmm
<offby1> j85wilson: so I'd need port->stream and stream->port
<j85wilson> yep
<j85wilson> having the stream underneath would mean that reading from the port wouldn't
<offby1> j85wilson: and is using streams, really, fundamentally different from what I'm doing now
<j85wilson> when you read from a port, the chars that you've read are gone.                [10:45]
<offby1> sure, that's why I've written this thing
<j85wilson> ports are fundamentally mutating things
<offby1> sure
<j85wilson> streams are not, yes?
<offby1> sure
<offby1> but the stream implementation is probably doing something similar to what I'm doing.
<zbigniew> sure
<j85wilson> could be
<offby1> (although, granted, it's probably doing it _better_ :-)
<j85wilson> but I suspect not, because instead of copying data, its just moving its looker down
<offby1> so your advice boils down to "don't reinvent the wheel", and I respect that
<offby1> hmm
<offby1> OK, I'll give it a try, then
<offby1> the whole point of writing this bot was for programming exercise, and this is surely
<zbigniew> it's like i suggested earlier, have one input copy and multiple file
<j85wilson> disclaim: I could be talking nonsense...  I haven't really worked with streams much
* zbigniew stares vaguely
<offby1> j85wilson: well, I'll do the research and see :-)                                 [10:47]
<j85wilson> zbigniew: your remark gave me the idea.
* zbigniew grants a tomb.
<j85wilson> Ulysses S. 's tomb?
<zbigniew> sure
<offby1> the one thing is that I want to be able to have a _main_ input stream-or-port, and split
* zbigniew recurses mildly                                                                 [10:48]
<j85wilson> I know guile has port->stream, if that helps                                   [10:49]
