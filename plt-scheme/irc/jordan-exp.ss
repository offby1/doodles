#! /bin/sh
#| Hey Emacs, this is -*-scheme-*- code!
#$Id$
exec mzscheme -M errortrace -qu "$0" ${1+"$@"}
|#

;; find funny quotes from jordanb in my IRC logs.  Note that this all
;; depends utterly on the format of the log files; in my case, they're
;; generated by the "ERC" client
;; (http://www.emacswiki.org/cgi-bin/wiki/ERC).

(module jordan-exp mzscheme
(require (only (lib "etc.ss") this-expression-source-directory)
         (lib "port.ss")
         (lib "trace.ss")
         (only (lib "1.ss" "srfi")
               append-map
               filter
               second
               take
               third)
         (only (planet "memoize.ss" ("dherman" "memoize.plt" )) define/memo)
         (only (planet "port-to-lines.ss" ("offby1" "offby1.plt"))
               file->lines
               port->lines
               )
         (planet "test.ss"    ("schematics" "schemeunit.plt" 2))
         (planet "util.ss"    ("schematics" "schemeunit.plt" 2))
         (planet "text-ui.ss" ("schematics" "schemeunit.plt" 2))
         (all-except (planet "fmt.ss"       ("ashinn"      "fmt.plt")) cat))
(provide all-jordanb-quotes
         one-jordanb-quote)

(define *pipe-max-bytes* 4096)

;; TODO -- perhaps, instead of grabbing quotes from my ~/log
;; directory, I should find some public logging service that logs
;; #emacs, and grab quotes from it.  The advantage is that anyone,not
;; just me, would then be able to run this code.

(define timestamp-regex
  (string-append
   "\\[[[:digit:]]{2}:[[:digit:]]{2}"
   "( [AP]M)?"
   "\\]"))

(define (nuke-trailing-timestamp str)
  (regexp-replace (pregexp
                   (string-append
                    "[[:space:]]*"
                    timestamp-regex
                    "[[:space:]]*$")
                   ) str ""))
(define (nuke-leading-timetamp str)
  (regexp-replace (pregexp
                   (string-append
                    "^[[:space:]]*"
                    timestamp-regex))
                  str ""
                  ))
;(trace nuke-trailing-timestamp)

(define *cache-file-name* (make-parameter (build-path (this-expression-source-directory) "cache.ss")))

;; it takes about half a minute to snarf up the files and grep them,
;; so we memoize this -- so that the second and subsequent calls are
;; fast.

;; hmm ... if a new file appears while the bot is running, it'll
;; invalidate this function's memoization cache, and force a complete
;; re-read.  Lotta work for little benefit.
(define/memo (all-jordanb-quotes filenames)
  (if (and (*cache-file-name*)
           (file-exists? (*cache-file-name*)))
      (begin
        (let ((rv (call-with-input-file (*cache-file-name*) read)))
          (fprintf (current-error-port)
                   "W00t!  Snarfed ~a hilarious quotes from cache file ~s.~%"
                   (length rv)
                   (*cache-file-name*))
          rv))
    (all-jordanb-quotes-no-memoizing filenames)))

(define (all-jordanb-quotes-no-memoizing filenames)
  (let ((rv (port->lines (funny-filter (joiner (stripper (cat filenames)))))))

    ;; we should probably move this to a separate utlity program, so
    ;; that I can regenerate the cache whenever I feel like it.
    (when (*cache-file-name*)
      (fprintf (current-error-port)
               "Damn, that took forever.  Saving hilarious quotes to cache file ~s.~%"
               *cache-file-name*)
      (call-with-output-file
          (*cache-file-name*)
        (lambda (op)
          (display "(" op) (newline op)
          (for-each
           (lambda (quote)
             (write quote op)
             (newline op))
           rv)
          (display ")" op) (newline op))
        'truncate/replace))
    rv))

;(trace all-jordanb-quotes)
(define (one-jordanb-quote)
  (let* ((log-dir (build-path (find-system-path 'home-dir) "log"))
         (all (all-jordanb-quotes
              (filter file-exists?
              (map
               (lambda (rfn) (build-path log-dir rfn))
               (directory-list log-dir ))))))

    (list-ref all (random (length all)))))



;; returns #f if the string doesn't look like the beginning of an
;; utterance.  If it does look like one, then returns a list, the
;; third element of which is the speaker's nick.
(define (beginning-of-utterance? str)
  (regexp-match (pregexp
                 (string-append
                  "^"
                  "(?:" timestamp-regex ")?"
                  "[[:space:]]*"
                  "<(" "[[:graph:]]+" ")>")) str))

;(trace beginning-of-utterance?)
(define (trim-leading-space str)
  (regexp-replace #rx"^[ \t]+" str ""))

;; (listof string?) -> input-port?
(define (cat filenames)
  (let-values (((ip op)
                ;; I might want to add a LIMIT-K argument, to keep the
                ;; pipe from getting too full.  Without that argument,
                ;; the new thread will never block, thus filling
                ;; memory.
                (make-pipe *pipe-max-bytes*)
                ))
    (thread
     (lambda ()
       (for-each
        (lambda (fn)
          (call-with-input-file fn
            (lambda (file-ip)
              (fprintf
               (current-error-port)
               "Pipe has ~a bytes in it; about to copy ~a bytes from ~s.~%"
               (fmt #f (num/comma (pipe-content-length op)))
               (fmt #f (num/comma (file-size fn)))
               fn)
              (copy-port file-ip op))))
        filenames)
       (close-output-port op)))
    ip))
;(trace cat)

;; input-port? -> input-port?
(define (stripper ip)
  (let-values (((rv op)
                (make-pipe *pipe-max-bytes*)))
    (thread
     (lambda ()
       (let loop ()
         (let ((line (read-line ip)))
           (when (not (eof-object? line))
             (display
               (nuke-trailing-timestamp (trim-leading-space (nuke-leading-timetamp line)))
              op)

             (newline op)
             (loop))))
       (close-output-port op)
       ))
    rv))
;(trace stripper)

;; input-port? -> input-port?
(define (joiner ip)
  (let-values (((rv op)
                (make-pipe *pipe-max-bytes*)))
    (thread
     (lambda ()
       (let loop ((one-partial-utterance ""))
         (let ((line (read-line ip)))
           (cond
            ((eof-object? line)
             (display  one-partial-utterance op)
             (newline op))
            ((beginning-of-utterance? line)
             (when (positive? (string-length one-partial-utterance))
                 (display one-partial-utterance op)
                 (newline op))
             (loop (trim-leading-space line)))
            (else
             ;; note: if the line begins with exactly ten spaces, an
             ;; asterisk, then another space, followed by a nonspace,
             ;; then it is _probably_ a "/me" line, as in

             "          * offby1 glances around nervously"

             ;; and hence should not be considered an addendum to the
             ;; current quote.

             ;; ten spaces, an asterisk, and a non-letter is probably
             ;; a message from the server like
             "*!*@adsl-69-236-*.dsl.pltn13.pacbell.net"

             ;; ten spaces, three asterisks, and a space is typically
             ;; and annoucement like
             "*** ##cinema: topic set by e1f`, 19:17:02 2007/05/02"

             ;; Occasionally we see the above with just seven spaces,
             ;; though :-|

             ;; survey the whole situation by running this at the
             ;; shell:

             ;; egrep --no-filename '^ *\*' ~/log/* | sort | uniq > /tmp/stars
             (let ((addendum (trim-leading-space line)))
               (loop (if (positive? (string-length addendum))
                         (string-append one-partial-utterance
                                        " "
                                        addendum)
                       one-partial-utterance
                       )))))))
       (close-output-port op)))
    rv))
;(trace joiner)

;; input-port? -> input-port?
;; only keeps amusing quotes from jordanb.
(define (funny-filter ip)
  (define (is-screamingly-funny? line)
    (regexp-match #rx"^(?i:<jordanb> +(let.?s.*)$)" line))
  (let-values (((rv op)
                (make-pipe *pipe-max-bytes*)))
    (thread
     (lambda ()
       (let loop ()
         (let ((line (read-line ip)))
           (when (not (eof-object? line))

             (when (is-screamingly-funny? line)
               (display line op)
               (newline op))
             (loop)))
         )
       (close-output-port op)))
    rv))

(when (positive?
       (test/text-ui
        (test-suite
         "Jordan-exp"
         (test-suite
          "beginning-of-utterance?"
          (test-not-false
           "yes, simple"
           (beginning-of-utterance? "<zamfir>"))
          (test-not-false
           "yes, leading whitespace"
           (beginning-of-utterance? " <zamfir>"))
          (test-not-false
           "ignore initial timestamp"
           (beginning-of-utterance? "[12:34]<harry>"))
          )

         (test-equal?
          "now, with added timestamps!!"
          (map nuke-trailing-timestamp (list "<me>huh   [12:34]" "  more huh [99:88]  " " yet more\t\t[00:00]" "<you>what ho?[18:19]"))
          (list "<me>huh" "  more huh" " yet more" "<you>what ho?"))

         (test-case
          "the whole shebang"
          (check-equal?
           (car
            (parameterize ((*cache-file-name* #f))
            (all-jordanb-quotes-no-memoizing (list "just-one-jordanb-quote.txt"))))
           "<jordanb> Let's start making a list. it'd be so coool."))
         (test-suite
          "filters"
          (test-equal?
           "cat"
           (port->lines (cat (list "yin" "yang")))
           (list
            "One yin line."
            "An unterminated yin line.Jerry Yang has no wang."))

          (test-case
           "stripping"
           (check-equal?
            (port->lines (stripper (open-input-string "[12:34]  Two spaces.")))
            (list "Two spaces."))
           (check-equal?
            (port->lines (stripper (open-input-string "  [12:34] Zamfir knows all.")))
            (list "Zamfir knows all."))
           (check-equal?
            (port->lines (stripper (open-input-string "  <x>Yo.")))
            (list "<x>Yo."))
           (check-equal?
            (port->lines (stripper (open-input-string "Yo.      [19:18]")))
            (list "Yo.")
            "trailing timestamps.")
           )

          (test-case
           "joining"
           (check-equal?
            (port->lines (joiner (open-input-string "<x> hey you\nI said hey you")))
            (list "<x> hey you I said hey you"))
           (check-equal?
            (port->lines (joiner (open-input-string "<x> hey you\n  <y>I said hey you")))
            (list "<x> hey you"
                  "<y>I said hey you"))
           (check-equal?
            (port->lines (joiner (open-input-string "<x> hey you\n\n\n\n\n\n\n")))
            (list "<x> hey you"))
           )))))
  (exit 1))

)