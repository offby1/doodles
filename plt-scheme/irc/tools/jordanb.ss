#! /bin/sh
#| Hey Emacs, this is -*-scheme-*- code!
#$Id$
exec mzscheme -M errortrace -qu "$0" ${1+"$@"}
|#

;; find funny quotes from jordanb in my IRC logs, and save them to a
;; file.  Note that this all depends utterly on the format of the log
;; files; in my case, they're generated by the "ERC" client
;; (http://www.emacswiki.org/cgi-bin/wiki/ERC).

(module jordanb mzscheme
(require (only (lib "etc.ss") this-expression-source-directory)
         (lib "port.ss")
         (lib "trace.ss")
         (only (lib "1.ss" "srfi")
               append-map
               filter
               second
               take
               third)
         (only (planet "memoize.ss" ("dherman" "memoize.plt" )) define/memo*)
         (only (planet "port-to-lines.ss" ("offby1" "offby1.plt"))
               file->lines
               port->lines
               )
         (planet "test.ss"    ("schematics" "schemeunit.plt" 2))
         (planet "util.ss"    ("schematics" "schemeunit.plt" 2))
         (planet "text-ui.ss" ("schematics" "schemeunit.plt" 2))
         (all-except (planet "fmt.ss"       ("ashinn"      "fmt.plt")) cat))

(define *pipe-max-bytes* (make-parameter #f))

;; TODO -- perhaps, instead of grabbing quotes from my ~/log
;; directory, I should find some public logging service that logs
;; #emacs, and grab quotes from it.  The advantage is that anyone,not
;; just me, would then be able to run this code.

(define timestamp-regex
  (string-append
   "\\[[[:digit:]]{2}:[[:digit:]]{2}"
   "( [AP]M)?"
   "\\]"))

(define (nuke-trailing-timestamp str)
  (regexp-replace (pregexp
                   (string-append
                    "[[:space:]]*"
                    timestamp-regex
                    "[[:space:]]*$")
                   ) str ""))
(define (nuke-leading-timetamp str)
  (regexp-replace (pregexp
                   (string-append
                    "^[[:space:]]*"
                    timestamp-regex))
                  str ""
                  ))

(define (spew-em filenames)
  (printf "-*-scheme-*-~%")
  (printf "(~%")
  (for-each
   (lambda (quote)
     (printf "~s~%" quote))
   (port->lines (funny-filter (joiner (stripper (cat filenames))))))
  (printf ")~%"))



;; returns #f if the string doesn't look like the beginning of an
;; utterance.  If it does look like one, then returns a list, the
;; third element of which is the speaker's nick.
(define (beginning-of-utterance? str)
  (regexp-match (pregexp
                 (string-append
                  "^"
                  "(?:" timestamp-regex ")?"
                  "[[:space:]]*"
                  "<(" "[[:graph:]]+" ")>")) str))

;(trace beginning-of-utterance?)
(define (trim-leading-space str)
  (regexp-replace #rx"^[ \t]+" str ""))

(define (make-filter writer)
  (let-values (((ip op)
                (make-pipe (*pipe-max-bytes*))))
    (thread (lambda () (writer op)))
    ip))

;; (listof string?) -> input-port?
(define (cat filenames)
  (make-filter
   (lambda (op)
     (for-each
      (lambda (fn)
        (with-handlers
            ((exn:fail:filesystem?
              (lambda (e)
                (fprintf (current-error-port)
                         "~a -- keepin' on keepin' on~%"
                        (exn-message e))
                )))
          (call-with-input-file fn
            (lambda (file-ip)
              (fprintf
               (current-error-port)
               "Pipe has ~a bytes in it; about to copy ~a bytes from ~s.~%"
               (fmt #f (num/comma (pipe-content-length op)))
               (fmt #f (num/comma (file-size fn)))
               fn)
              (copy-port file-ip op)))))
      filenames)
     (close-output-port op))))
;(trace cat)

;; input-port? -> input-port?
(define (stripper ip)
  (make-filter
   (lambda (op)
     (let loop ()
       (let ((line (read-line ip)))
         (when (not (eof-object? line))
           (display
            (nuke-trailing-timestamp (trim-leading-space (nuke-leading-timetamp line)))
            op)

           (newline op)
           (loop))))
     (close-output-port op)
     )))
;(trace stripper)

;; input-port? -> input-port?
(define (joiner ip)
  (make-filter
   (lambda (op)
     (let loop ((one-partial-utterance ""))
       (let ((line (read-line ip)))
         (cond
          ((eof-object? line)
           (display  one-partial-utterance op)
           (newline op))
          ((beginning-of-utterance? line)
           (when (positive? (string-length one-partial-utterance))
             (display one-partial-utterance op)
             (newline op))
           (loop (trim-leading-space line)))
          (else
           ;; note: if the line begins with exactly ten spaces, an
           ;; asterisk, then another space, followed by a nonspace,
           ;; then it is _probably_ a "/me" line, as in

           "          * offby1 glances around nervously"

           ;; and hence should not be considered an addendum to the
           ;; current quote.

           ;; ten spaces, an asterisk, and a non-letter is probably
           ;; a message from the server like
           "*!*@adsl-69-236-*.dsl.pltn13.pacbell.net"

           ;; ten spaces, three asterisks, and a space is typically
           ;; and annoucement like
           "*** ##cinema: topic set by e1f`, 19:17:02 2007/05/02"

           ;; Occasionally we see the above with just seven spaces,
           ;; though :-|

           ;; survey the whole situation by running this at the
           ;; shell:

           ;; egrep --no-filename '^ *\*' ~/log/* | sort | uniq > /tmp/stars
           (let ((addendum (trim-leading-space line)))
             (loop
              ;; TODO -- see if some function ("string-join"?) will
              ;; encapsulate the "if" check for me
              (if (positive? (string-length addendum))
                  (string-append one-partial-utterance
                                 " "
                                 addendum)
                one-partial-utterance
                )))))))
     (close-output-port op))))
;(trace joiner)

(define (truncate-stuff-past-end-of-sentence str)
  (regexp-replace (pregexp "([.?!]+).*?$") str "\\1"))

;; input-port? -> input-port?
;; only keeps amusing quotes from jordanb.
(define (funny-filter ip)
  (define (is-screamingly-funny? line)
    (or
     (regexp-match #rx"^(?i:<jordanb> +(.*taken out back.*)$)" line)
     (regexp-match #rx"^(?i:<jordanb> +((let.?s|we should|i love it how|I'll .* you).*)$)" line)))
  (make-filter
   (lambda (op)
     (let loop ()
       (let ((line (read-line ip)))
         (when (not (eof-object? line))
           (let ((funnitude  (is-screamingly-funny? line)))
             (when funnitude
               (display (truncate-stuff-past-end-of-sentence (second funnitude)) op)
               (newline op)))
           (loop)))
       )
     (close-output-port op))))

(parameterize ((current-output-port (current-error-port)))
(when (positive?
       (test/text-ui
        (test-suite
         "Jordanb"

         (test-suite
          "beginning-of-utterance?"
          (test-not-false
           "yes, simple"
           (beginning-of-utterance? "<zamfir>"))
          (test-not-false
           "yes, leading whitespace"
           (beginning-of-utterance? " <zamfir>"))
          (test-not-false
           "ignore initial timestamp"
           (beginning-of-utterance? "[12:34]<harry>"))
          (test-false
           "missing <"
           (beginning-of-utterance? " forcer> "))
          (test-false
           "gap after initial <"
           (beginning-of-utterance? "< forcer> "))
          (test-false
           "empty nick"
           (beginning-of-utterance? "<>"))
          )

         (test-equal?
          "now, with added timestamps!!"
          (map nuke-trailing-timestamp (list "<me>huh   [12:34]" "  more huh [99:88]  " " yet more\t\t[00:00]" "<you>what ho?[18:19]"))
          (list "<me>huh" "  more huh" " yet more" "<you>what ho?"))

         (test-suite
          "truncate-stuff-past-end-of-sentence"
          (test-equal? "no punctuation"  (truncate-stuff-past-end-of-sentence "foo bar") "foo bar")
          (test-equal? "simple sentence" (truncate-stuff-past-end-of-sentence "foo.") "foo.")
          (test-equal? "the main event" (truncate-stuff-past-end-of-sentence "foo. Bar!") "foo.")
          (test-equal? "?" (truncate-stuff-past-end-of-sentence "foo? Bar!") "foo?")
          (test-equal? "!" (truncate-stuff-past-end-of-sentence "foo! Bar!") "foo!")
          (test-equal? "keeps all punct chars" (truncate-stuff-past-end-of-sentence "foo, Bar!!!!") "foo, Bar!!!!")
          )
         (test-suite
          "filters"
          (test-equal?
           "cat"
           (port->lines (parameterize ((current-error-port (open-output-bytes)))
                        (cat (map (lambda (rfn)
                                    (build-path
                                     (this-expression-source-directory)
                                     "test-data"
                                     rfn))
                                  (list "yin" "yang")))))
           (list
            "One yin line."
            "An unterminated yin line.Jerry Yang has no wang."))

          (test-case
           "stripping"
           (check-equal?
            (port->lines (stripper (open-input-string "[12:34]  Two spaces.")))
            (list "Two spaces."))
           (check-equal?
            (port->lines (stripper (open-input-string "  [12:34] Zamfir knows all.")))
            (list "Zamfir knows all."))
           (check-equal?
            (port->lines (stripper (open-input-string "  <x>Yo.")))
            (list "<x>Yo."))
           (check-equal?
            (port->lines (stripper (open-input-string "Yo.      [19:18]")))
            (list "Yo.")
            "trailing timestamps.")
           )

          (test-case
           "joining"
           (check-equal?
            (port->lines (joiner (open-input-string "<x> hey you\nI said hey you")))
            (list "<x> hey you I said hey you"))
           (check-equal?
            (port->lines (joiner (open-input-string "<x> hey you\n  <y>I said hey you")))
            (list "<x> hey you"
                  "<y>I said hey you"))
           (check-equal?
            (port->lines (joiner (open-input-string "<x> hey you\n\n\n\n\n\n\n")))
            (list "<x> hey you"))
           )))
        ))
  (exit 1)))
(spew-em
 (let ((log-dir (build-path (find-system-path 'home-dir) "log")))
   (filter file-exists?
           (map
            (lambda (rfn) (build-path log-dir rfn))
            (directory-list log-dir )))))

)