#! /bin/sh
#| Hey Emacs, this is -*-scheme-*- code!
#$Id$
exec mzscheme -M errortrace -qu "$0" ${1+"$@"}
|#

;; find funny quotes from jordanb in my IRC logs.  Note that this all
;; depends utterly on the format of the log files; in my case, they're
;; generated by the "ERC" client
;; (http://www.emacswiki.org/cgi-bin/wiki/ERC).

(module jordanb mzscheme
(require (only (lib "etc.ss") this-expression-source-directory)
         (lib "port.ss")
         (lib "trace.ss")
         (only (lib "1.ss" "srfi")
               append-map
               filter
               second
               take
               third)
         (only (planet "memoize.ss" ("dherman" "memoize.plt" )) define/memo*)
         (only (planet "port-to-lines.ss" ("offby1" "offby1.plt"))
               file->lines
               port->lines
               )
         (planet "test.ss"    ("schematics" "schemeunit.plt" 2))
         (planet "util.ss"    ("schematics" "schemeunit.plt" 2))
         (planet "text-ui.ss" ("schematics" "schemeunit.plt" 2))
         (all-except (planet "fmt.ss"       ("ashinn"      "fmt.plt")) cat))
(provide *cache-file-name*
         *pipe-max-bytes*
         all-jordanb-quotes
         one-jordanb-quote)

(define *pipe-max-bytes* (make-parameter 4096))

;; TODO -- perhaps, instead of grabbing quotes from my ~/log
;; directory, I should find some public logging service that logs
;; #emacs, and grab quotes from it.  The advantage is that anyone,not
;; just me, would then be able to run this code.

(define timestamp-regex
  (string-append
   "\\[[[:digit:]]{2}:[[:digit:]]{2}"
   "( [AP]M)?"
   "\\]"))

(define (nuke-trailing-timestamp str)
  (regexp-replace (pregexp
                   (string-append
                    "[[:space:]]*"
                    timestamp-regex
                    "[[:space:]]*$")
                   ) str ""))
(define (nuke-leading-timetamp str)
  (regexp-replace (pregexp
                   (string-append
                    "^[[:space:]]*"
                    timestamp-regex))
                  str ""
                  ))
;(trace nuke-trailing-timestamp)

(define *cache-file-name* (make-parameter (build-path (this-expression-source-directory) "cache.ss")))

;; it takes about half a minute to snarf up the files and grep them,
;; so we memoize this -- so that the second and subsequent calls are
;; fast.

;; hmm ... if a new file appears while the bot is running, it'll
;; invalidate this function's memoization cache, and force a complete
;; re-read.  Lotta work for little benefit.
(define/memo* (all-jordanb-quotes filenames)
  (if (and (*cache-file-name*)
           (file-exists? (*cache-file-name*)))
      (begin
        (let ((rv (call-with-input-file (*cache-file-name*) read)))
          (fprintf (current-error-port)
                   "W00t!  Snarfed ~a hilarious quotes from cache file ~s.~%"
                   (length rv)
                   (*cache-file-name*))
          rv))
    (all-jordanb-quotes-no-memoizing filenames)))

(define (all-jordanb-quotes-no-memoizing filenames)
  (let ((rv (port->lines (funny-filter (joiner (stripper (cat filenames)))))))

    ;; we should probably move this to a separate utlity program, so
    ;; that I can regenerate the cache whenever I feel like it.
    (when (*cache-file-name*)
      (fprintf (current-error-port)
               "Damn, that took forever.  Saving comedy gold to cache file ~s.~%"
               (*cache-file-name*))
      (call-with-output-file
          (*cache-file-name*)
        (lambda (op)
          (display "(" op) (newline op)
          (for-each
           (lambda (quote)
             (write quote op)
             (newline op))
           rv)
          (display ")" op) (newline op))
        'truncate/replace))
    rv))

;(trace all-jordanb-quotes)
(define (one-jordanb-quote)
  (let* ((log-dir (build-path (find-system-path 'home-dir) "log"))
         (all (all-jordanb-quotes
              (filter file-exists?
              (map
               (lambda (rfn) (build-path log-dir rfn))
               (directory-list log-dir ))))))

    (list-ref all (random (length all)))))



;; returns #f if the string doesn't look like the beginning of an
;; utterance.  If it does look like one, then returns a list, the
;; third element of which is the speaker's nick.
(define (beginning-of-utterance? str)
  (regexp-match (pregexp
                 (string-append
                  "^"
                  "(?:" timestamp-regex ")?"
                  "[[:space:]]*"
                  "<(" "[[:graph:]]+" ")>")) str))

;(trace beginning-of-utterance?)
(define (trim-leading-space str)
  (regexp-replace #rx"^[ \t]+" str ""))

(define (make-filter writer)
  (let-values (((ip op)
                ;; I might want to add a LIMIT-K argument, to keep the
                ;; pipe from getting too full.  Without that argument,
                ;; the new thread will never block, thus filling
                ;; memory.
                (make-pipe (*pipe-max-bytes*))))
    (thread (lambda () (writer op)))
    ip))

;; (listof string?) -> input-port?
(define (cat filenames)
  (make-filter
   (lambda (op)
     (for-each
      (lambda (fn)
        (with-handlers
            ((exn:fail:filesystem?
              (lambda (e)
                (printf "~a -- keepin' on keepin' on~%"
                        (exn-message e))
                )))
          (call-with-input-file fn
            (lambda (file-ip)
              (fprintf
               (current-error-port)
               "Pipe has ~a bytes in it; about to copy ~a bytes from ~s.~%"
               (fmt #f (num/comma (pipe-content-length op)))
               (fmt #f (num/comma (file-size fn)))
               fn)
              (copy-port file-ip op)))))
      filenames)
     (close-output-port op))))
;(trace cat)

;; input-port? -> input-port?
(define (stripper ip)
  (make-filter
   (lambda (op)
     (let loop ()
       (let ((line (read-line ip)))
         (when (not (eof-object? line))
           (display
            (nuke-trailing-timestamp (trim-leading-space (nuke-leading-timetamp line)))
            op)

           (newline op)
           (loop))))
     (close-output-port op)
     )))
;(trace stripper)

;; input-port? -> input-port?
(define (joiner ip)
  (make-filter
   (lambda (op)
     (let loop ((one-partial-utterance ""))
       (let ((line (read-line ip)))
         (cond
          ((eof-object? line)
           (display  one-partial-utterance op)
           (newline op))
          ((beginning-of-utterance? line)
           (when (positive? (string-length one-partial-utterance))
             (display one-partial-utterance op)
             (newline op))
           (loop (trim-leading-space line)))
          (else
           ;; note: if the line begins with exactly ten spaces, an
           ;; asterisk, then another space, followed by a nonspace,
           ;; then it is _probably_ a "/me" line, as in

           "          * offby1 glances around nervously"

           ;; and hence should not be considered an addendum to the
           ;; current quote.

           ;; ten spaces, an asterisk, and a non-letter is probably
           ;; a message from the server like
           "*!*@adsl-69-236-*.dsl.pltn13.pacbell.net"

           ;; ten spaces, three asterisks, and a space is typically
           ;; and annoucement like
           "*** ##cinema: topic set by e1f`, 19:17:02 2007/05/02"

           ;; Occasionally we see the above with just seven spaces,
           ;; though :-|

           ;; survey the whole situation by running this at the
           ;; shell:

           ;; egrep --no-filename '^ *\*' ~/log/* | sort | uniq > /tmp/stars
           (let ((addendum (trim-leading-space line)))
             (loop (if (positive? (string-length addendum))
                       (string-append one-partial-utterance
                                      " "
                                      addendum)
                     one-partial-utterance
                     )))))))
     (close-output-port op))))
;(trace joiner)

(define (truncate-stuff-past-end-of-sentence str)
  (regexp-replace (pregexp "([.?!]+).*?$") str "\\1"))

;; input-port? -> input-port?
;; only keeps amusing quotes from jordanb.
(define (funny-filter ip)
  (define (is-screamingly-funny? line)
    (regexp-match #rx"^(?i:<jordanb> +(let.?s.*)$)" line))
  (make-filter
   (lambda (op)
     (let loop ()
       (let ((line (read-line ip)))
         (when (not (eof-object? line))
           (let ((funnitude  (is-screamingly-funny? line)))
             (when funnitude
               (display (truncate-stuff-past-end-of-sentence (second funnitude)) op)
               (newline op)))
           (loop)))
       )
     (close-output-port op))))

(when (positive?
       (test/text-ui
        (test-suite
         "Jordanb"

         (test-pred
          "doesn't panic on non-existing file"
          null?
          (parameterize ((*cache-file-name* #f))
                        (all-jordanb-quotes (list "snsldkfjdlfkjdsf"))))

         (test-suite
          "beginning-of-utterance?"
          (test-not-false
           "yes, simple"
           (beginning-of-utterance? "<zamfir>"))
          (test-not-false
           "yes, leading whitespace"
           (beginning-of-utterance? " <zamfir>"))
          (test-not-false
           "ignore initial timestamp"
           (beginning-of-utterance? "[12:34]<harry>"))
          (test-false
           "missing <"
           (beginning-of-utterance? " forcer> "))
          (test-false
           "gap after initial <"
           (beginning-of-utterance? "< forcer> "))
          (test-false
           "empty nick"
           (beginning-of-utterance? "<>"))
          )

         (test-equal?
          "now, with added timestamps!!"
          (map nuke-trailing-timestamp (list "<me>huh   [12:34]" "  more huh [99:88]  " " yet more\t\t[00:00]" "<you>what ho?[18:19]"))
          (list "<me>huh" "  more huh" " yet more" "<you>what ho?"))

         (test-case
          "the whole shebang"
          (check-equal?
           (car
            (parameterize ((*cache-file-name* #f))
                          (all-jordanb-quotes-no-memoizing
                           (list
                            (build-path
                             (this-expression-source-directory)
                             "test-data"
                             "just-one-jordanb-quote.txt")))))
           "Let's start making a list, it'd be so coool."))
         (test-suite
          "truncate-stuff-past-end-of-sentence"
          (test-equal? "no punctuation"  (truncate-stuff-past-end-of-sentence "foo bar") "foo bar")
          (test-equal? "simple sentence" (truncate-stuff-past-end-of-sentence "foo.") "foo.")
          (test-equal? "the main event" (truncate-stuff-past-end-of-sentence "foo. Bar!") "foo.")
          (test-equal? "?" (truncate-stuff-past-end-of-sentence "foo? Bar!") "foo?")
          (test-equal? "!" (truncate-stuff-past-end-of-sentence "foo! Bar!") "foo!")
          (test-equal? "keeps all punct chars" (truncate-stuff-past-end-of-sentence "foo, Bar!!!!") "foo, Bar!!!!")
          )
         (test-suite
          "filters"
          (test-equal?
           "cat"
           (port->lines (cat (map (lambda (rfn)
                                    (build-path
                                     (this-expression-source-directory)
                                     "test-data"
                                     rfn))
                                  (list "yin" "yang"))))
           (list
            "One yin line."
            "An unterminated yin line.Jerry Yang has no wang."))

          (test-case
           "stripping"
           (check-equal?
            (port->lines (stripper (open-input-string "[12:34]  Two spaces.")))
            (list "Two spaces."))
           (check-equal?
            (port->lines (stripper (open-input-string "  [12:34] Zamfir knows all.")))
            (list "Zamfir knows all."))
           (check-equal?
            (port->lines (stripper (open-input-string "  <x>Yo.")))
            (list "<x>Yo."))
           (check-equal?
            (port->lines (stripper (open-input-string "Yo.      [19:18]")))
            (list "Yo.")
            "trailing timestamps.")
           )

          (test-case
           "joining"
           (check-equal?
            (port->lines (joiner (open-input-string "<x> hey you\nI said hey you")))
            (list "<x> hey you I said hey you"))
           (check-equal?
            (port->lines (joiner (open-input-string "<x> hey you\n  <y>I said hey you")))
            (list "<x> hey you"
                  "<y>I said hey you"))
           (check-equal?
            (port->lines (joiner (open-input-string "<x> hey you\n\n\n\n\n\n\n")))
            (list "<x> hey you"))
           )))
        ))
  (exit 1))

)