I would like "command-line" to allow me to validate flag-specific
arguments.

What do I mean by this?  Let's say my program has a global parameter
"*haircut-interval*" that should be an integer, and I want to be able
to set that value from the command line.  If I get the command line
wrong, I would like an error message that says what I did wrong, along
with the same output that I would have gotten if I had passed the
"--help" flag, like this:

        mzscheme -qr cmdline-suggestion.ss --haircut-interval never
        --haircut-interval: Yo, I want an exact positive integer, not "never"
        Allow me to show you the proper syntax:
        yo [ <option> ... ]
         where <option> is one of
          --haircut-interval <secs> : Seconds to wait before getting a haircut
          --help, -h : Show this help
          -- : Do not treat any remaining argument as a switch (at this level)

I can come pretty close to this with the attached program, but it has
some flaws:

* The error message that it emits refers to the name of the parameter,
  not the flag.  This is less useful for the user, who doesn't care
  about the names of internal objects inside the program

* I had to go to some effort to raise an error, catch it, and then
  re-invoke the command-line parser with the "--help" option.

It's that second bit that I wish command-line would do for me.
Specifically, it could evaluate the flag-specs "body-exprs" inside an
exception handler; that handler would "pass through" all exceptions
except for those of a particular type "exn:fail:user:cmdline".  But if it
got an exception of that type, it would display the message to
current-error-port, then display the "--help" message, then exit.

That would allow me to eliminate the weird "with-handlers" form (and
move the type checks from the parameter's guard procedure into the
flag-spec's body-expr), and be confident that, if "cmdline-parser"
returns, all the options' values were acceptable to me.
