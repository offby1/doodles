rewrite the guts of the bot.

It'll read lines from the IRC server socket, and transform them into a
stream of lines, which will be a big fat global variable.

The output port for writing to the server will also be a global.

Then there will be a number of tasks, each of which looks something
like this

(stream-for-each
 (lambda (string)
   (mumble string)
   (fprintf 
    *output-port-for-server*
    "PRIVMSG #some-channel :oh, ~a is very funny" string))
 (stream-filter
  (lambda (string)
    (regexp-match #rx"news$" string))
  *lines-from-server*))

...

or with requisite refactoring

(blubber
  (lambda (string)
    (regexp-match #rx"news$" string))
 
  (lambda (string)
   (mumble string)
   (fprintf 
    *output-port-for-server*
    "PRIVMSG #some-channel :oh, ~a is very funny" string)))

...

perhaps blubber could pass the value from the first procedure to the
second:


(blubber
  (lambda (string)
    (cond
      ((regexp-match #rx"news$" string)
       => tokenize)))
 
  (lambda (tokens)
   (mumble (first tokens))
   (fprintf 
    *output-port-for-server*
    "PRIVMSG #some-channel :oh, ~a is very funny" (second tokens))))


Riastradh suggests something like

(define (jordanb-chatter)
  (sync 
   (choose-evt
    (wrap-evt (channel-input-evt)
              (lambda ignore (jordanb-chatter)))
    (wrap-evt (timer-evt (* 20 60 1000))
              (lambda ignore
                (say-something-funny)
                (jordanb-chatter))))))
